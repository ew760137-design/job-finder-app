# üì¶ Project: WhatsApp Job App ‚Äî Staging Starter

This repo is a **single-machine staging system** you can run locally or on a small VPS. It includes:
- FastAPI backend (payments webhooks, WhatsApp sandbox endpoints, AI-ish problem solver stubs)
- SQLite DB schema (users, jobs, subscriptions, payments, ledger, wallet, referrals, payouts, audit)
- Minimal admin dashboard (HTML+JS) with **line graph** (actual) and **dashed forecast**
- Sample cron-like job ingestor (mock jobs), referral & wallet automation, fraud guards
- Stripe/PayPal/Flutterwave **sandbox** webhooks (no real money)

> ‚ö†Ô∏è Staging only. You will paste **real keys** later for production.

---

## üóÇÔ∏è File Tree
```
whatsapp-job-staging/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ schema.sql
‚îÇ   ‚îú‚îÄ‚îÄ seeds.py
‚îÇ   ‚îú‚îÄ‚îÄ utils.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ static/
‚îÇ       ‚îú‚îÄ‚îÄ dashboard.html
‚îÇ       ‚îî‚îÄ‚îÄ chart.min.js   # vendored Chart.js (or use CDN)
‚îî‚îÄ‚îÄ README.md
```

---

## ‚öôÔ∏è docker-compose.yml
```yaml
version: "3.9"
services:
  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: whatsapp_job_api
    env_file:
      - ../.env
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app
    restart: unless-stopped
```

---

## üîê .env.example
```env
# === WhatsApp Cloud API (Sandbox) ===
WHATSAPP_VERIFY_TOKEN=replace_me
WHATSAPP_APP_ID=app_id_here
WHATSAPP_APP_SECRET=app_secret_here
WHATSAPP_PHONE_NUMBER_ID=phone_number_id_here

# === Payments (Sandbox/Test keys) ===
STRIPE_SECRET_KEY=sk_test_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx
PAYPAL_CLIENT_ID=paypal_sandbox_client_id
PAYPAL_CLIENT_SECRET=paypal_sandbox_secret
FLUTTERWAVE_SECRET_KEY=flw_test_secret
FLUTTERWAVE_WEBHOOK_HASH=flw_webhook_hash

# === Crypto (optional test) ===
CRYPTO_WEBHOOK_SECRET=crypto_secret

# === App ===
JWT_SECRET=change_me
ENCRYPTION_KEY=32_bytes_hex_key_change_me
DATABASE_URL=sqlite:///./staging.db
DEFAULT_GROWTH_RATE=0.10
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=Admin@12345
```

---

## üß± backend/requirements.txt
```
fastapi==0.112.0
uvicorn[standard]==0.30.0
pydantic==2.8.2
pydantic-settings==2.4.0
python-multipart==0.0.9
requests==2.32.3
httpx==0.27.0
passlib[bcrypt]==1.7.4
pyjwt==2.9.0
sqlalchemy==2.0.31
aiosqlite==0.20.0
jinja2==3.1.4
```

---

## üß™ backend/schema.sql
```sql
-- Users & Auth
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  phone TEXT UNIQUE,
  name TEXT,
  country TEXT,
  language TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Subscriptions
CREATE TABLE IF NOT EXISTS subscriptions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  plan TEXT,              -- daily, weekly, monthly, elite, annual
  price_cents INTEGER,
  currency TEXT,
  start_at DATETIME,
  end_at DATETIME,
  active INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Payments (inbound)
CREATE TABLE IF NOT EXISTS payments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  provider TEXT,          -- stripe, paypal, flutterwave, crypto, manual
  provider_txn_id TEXT UNIQUE,
  user_id INTEGER,
  amount_cents INTEGER,
  currency TEXT,
  plan TEXT,
  status TEXT,            -- succeeded, failed, pending
  raw JSON,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Ledger (append-only)
CREATE TABLE IF NOT EXISTS ledger (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  entry_id TEXT UNIQUE,   -- idempotency key / provider event id
  user_id INTEGER,
  type TEXT,              -- credit, debit
  reason TEXT,            -- subscription, referral_bonus, payout
  amount_cents INTEGER,
  currency TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Wallet (computed but cached)
CREATE TABLE IF NOT EXISTS wallets (
  user_id INTEGER PRIMARY KEY,
  balance_cents INTEGER DEFAULT 0,
  currency TEXT DEFAULT 'USD',
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Referrals
CREATE TABLE IF NOT EXISTS referrals (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  referrer_user_id INTEGER,
  referred_user_id INTEGER,
  paid INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Payouts (outbound)
CREATE TABLE IF NOT EXISTS payouts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  amount_cents INTEGER,
  currency TEXT,
  method TEXT,            -- mobile_money, paypal, bank, crypto
  destination TEXT,
  status TEXT,            -- pending, processing, paid, failed
  provider_txn_id TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Jobs
CREATE TABLE IF NOT EXISTS jobs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT,
  country TEXT,
  language TEXT,
  description TEXT,
  requirements TEXT,
  salary_usd INTEGER,
  source TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Audit Log
CREATE TABLE IF NOT EXISTS audit (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  who TEXT,
  action TEXT,
  detail TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

---

## üß∞ backend/utils.py (helpers: db, auth, forecasting, wallets)
```python
import math, time, json
from datetime import datetime, timedelta
from typing import List, Dict

from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

import jwt
from passlib.hash import bcrypt

DATABASE_URL = None
JWT_SECRET = None
DEFAULT_GROWTH_RATE = 0.10

_engine = None
_Session = None

def init(env):
    global DATABASE_URL, JWT_SECRET, DEFAULT_GROWTH_RATE, _engine, _Session
    DATABASE_URL = env.DATABASE_URL
    JWT_SECRET = env.JWT_SECRET
    DEFAULT_GROWTH_RATE = float(env.DEFAULT_GROWTH_RATE or 0.10)
    _engine = create_engine(DATABASE_URL, future=True)
    _Session = sessionmaker(bind=_engine, autoflush=False, future=True)

def db():
    return _Session()

# Simple JWT
def make_token(user_id: int):
    return jwt.encode({"uid": user_id, "iat": int(time.time())}, JWT_SECRET, algorithm="HS256")

def verify_token(token: str):
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        return payload.get("uid")
    except Exception:
        return None

# Forecasting: naive compounding growth
def forecast_series(actual: List[Dict], months=6, growth=None):
    growth = growth if growth is not None else DEFAULT_GROWTH_RATE
    if not actual:
        return []
    last = actual[-1]["total"]
    start_date = datetime.strptime(actual[-1]["period"], "%Y-%m")
    out = []
    for i in range(1, months+1):
        last = last * (1 + growth)
        period = (start_date + timedelta(days=30*i)).strftime("%Y-%m")
        out.append({"period": period, "total": round(last, 2)})
    return out

# Wallet compute/apply
def wallet_adjust(session, user_id: int, delta_cents: int, currency: str = "USD", reason: str = "misc", entry_id: str = None):
    if entry_id:
        # idempotency via ledger.entry_id unique
        session.execute(text("INSERT OR IGNORE INTO ledger(entry_id,user_id,type,reason,amount_cents,currency) VALUES(:e,:u,:t,:r,:a,:c)"),
                        {"e": entry_id, "u": user_id, "t": "credit" if delta_cents>0 else "debit", "r": reason, "a": abs(delta_cents), "c": currency})
    else:
        session.execute(text("INSERT INTO ledger(user_id,type,reason,amount_cents,currency) VALUES(:u,:t,:r,:a,:c)"),
                        {"u": user_id, "t": "credit" if delta_cents>0 else "debit", "r": reason, "a": abs(delta_cents), "c": currency})
    # Upsert wallet
    row = session.execute(text("SELECT balance_cents,currency FROM wallets WHERE user_id=:u"), {"u": user_id}).fetchone()
    if row:
        new_bal = row[0] + delta_cents
        session.execute(text("UPDATE wallets SET balance_cents=:b, currency=:c, updated_at=CURRENT_TIMESTAMP WHERE user_id=:u"),
                        {"b": new_bal, "c": currency, "u": user_id})
    else:
        session.execute(text("INSERT INTO wallets(user_id,balance_cents,currency) VALUES(:u,:b,:c)"),
                        {"u": user_id, "b": delta_cents, "c": currency})
```

---

## üå± backend/seeds.py (seed mock data)
```python
from sqlalchemy import text
from utils import db

def seed_all():
    s = db()
    # Users
    users = [
        ("+256700000001", "Alice", "Uganda", "en"),
        ("+254700000002", "Brian", "Kenya", "sw"),
        ("+919000000003", "Chitra", "India", "en"),
    ]
    for phone, name, country, lang in users:
        s.execute(text("INSERT OR IGNORE INTO users(phone,name,country,language) VALUES(:p,:n,:c,:l)"),
                  {"p": phone, "n": name, "c": country, "l": lang})

    # Jobs (mock)
    jobs = [
        ("Accountant", "Uganda", "en", "Manage ledgers, reports", "CPA, Excel", 700, "mock"),
        ("Software Engineer", "Kenya", "en", "Build APIs", "Python, FastAPI", 1800, "mock"),
        ("Sales Rep", "India", "en", "Prospect clients", "CRM, Communication", 900, "mock"),
    ]
    for j in jobs:
        s.execute(text("INSERT INTO jobs(title,country,language,description,requirements,salary_usd,source) VALUES(:t,:c,:l,:d,:r,:s,:o)"),
                  {"t": j[0], "c": j[1], "l": j[2], "d": j[3], "r": j[4], "s": j[5], "o": j[6]})

    s.commit()
```

---

## üñ•Ô∏è backend/static/dashboard.html (line graph + forecast)
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin Dashboard ‚Äî Earnings</title>
  <style>
    body{font-family:system-ui, Arial, sans-serif; margin:20px}
    .cards{display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:12px}
    .card{padding:14px; border:1px solid #e5e7eb; border-radius:14px; box-shadow:0 1px 4px rgba(0,0,0,.04)}
    canvas{max-width:100%; height:360px}
    .muted{color:#6b7280; font-size:12px}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>üìä Revenue Dashboard</h1>
  <div class="cards" id="cards"></div>
  <h2>Revenue (Actual vs Forecast)</h2>
  <canvas id="revChart"></canvas>
  <p class="muted">Solid = actual, Dashed = forecast</p>
  <script>
    async function load(){
      const cardsEl = document.getElementById('cards');
      const [summary, series] = await Promise.all([
        fetch('/api/summary').then(r=>r.json()),
        fetch('/api/revenue/series').then(r=>r.json())
      ]);
      cardsEl.innerHTML = `
        <div class="card">üíµ Total Revenue: <b>$${(summary.total_revenue/100).toFixed(2)}</b></div>
        <div class="card">üìÜ This Month: <b>$${(summary.month_revenue/100).toFixed(2)}</b></div>
        <div class="card">‚è∞ Today: <b>$${(summary.today_revenue/100).toFixed(2)}</b></div>
        <div class="card">üë• Active Subs: <b>${summary.active_subscriptions}</b></div>
      `;
      const ctx = document.getElementById('revChart');
      const labels = [...series.actual.map(x=>x.period), ...series.forecast.map(x=>x.period)];
      const actualData = series.actual.map(x=>x.total/100);
      const forecastData = [...new Array(series.actual.length-1).fill(null), ...series.forecast.map(x=>x.total/100)];
      new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Actual', data: actualData, borderWidth: 2 },
            { label: 'Forecast', data: forecastData, borderWidth: 2, borderDash: [6,6] }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          scales: { y: { beginAtZero: true } }
        }
      });
    }
    load();
  </script>
</body>
</html>
```

---

## üêç backend/main.py (FastAPI app)
```python
import os, json
from datetime import datetime, timedelta
from typing import Optional, List, Dict

from fastapi import FastAPI, Request, Depends, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from pydantic_settings import BaseSettings
from sqlalchemy import text

from utils import init as utils_init, db, wallet_adjust, forecast_series

class Settings(BaseSettings):
    WHATSAPP_VERIFY_TOKEN: str = ""
    WHATSAPP_APP_ID: str = ""
    WHATSAPP_APP_SECRET: str = ""
    WHATSAPP_PHONE_NUMBER_ID: str = ""

    STRIPE_SECRET_KEY: str = ""
    STRIPE_WEBHOOK_SECRET: str = ""
    PAYPAL_CLIENT_ID: str = ""
    PAYPAL_CLIENT_SECRET: str = ""
    FLUTTERWAVE_SECRET_KEY: str = ""
    FLUTTERWAVE_WEBHOOK_HASH: str = ""
    CRYPTO_WEBHOOK_SECRET: str = ""

    JWT_SECRET: str = ""
    ENCRYPTION_KEY: str = ""
    DATABASE_URL: str = "sqlite:///./staging.db"
    DEFAULT_GROWTH_RATE: float = 0.10
    ADMIN_EMAIL: str = "admin@example.com"
    ADMIN_PASSWORD: str = "Admin@12345"

    class Config:
        env_file = "../.env"

app = FastAPI(title="WhatsApp Job App ‚Äî Staging")
settings = Settings()
utils_init(settings)

# Ensure DB schema
with open(os.path.join(os.path.dirname(__file__), "schema.sql"), "r") as f:
    sql = f.read()
    s = db(); s.execute(text(sql)); s.commit(); s.close()

# Seed demo data
from seeds import seed_all
seed_all()

# Static dashboard
app.mount("/static", StaticFiles(directory=os.path.join(os.path.dirname(__file__), "static")), name="static")

@app.get("/", response_class=HTMLResponse)
def home():
    with open(os.path.join(os.path.dirname(__file__), "static", "dashboard.html"), "r") as f:
        return f.read()

# =============== SUMMARY / METRICS APIs ===============
@app.get("/api/summary")
def summary():
    s = db()
    total = s.execute(text("SELECT COALESCE(SUM(amount_cents),0) FROM payments WHERE status='succeeded'")) .scalar() or 0
    today = s.execute(text("SELECT COALESCE(SUM(amount_cents),0) FROM payments WHERE status='succeeded' AND date(created_at)=date('now')")) .scalar() or 0
    month = s.execute(text("SELECT COALESCE(SUM(amount_cents),0) FROM payments WHERE status='succeeded' AND strftime('%Y-%m', created_at)=strftime('%Y-%m','now')")) .scalar() or 0
    active = s.execute(text("SELECT COUNT(1) FROM subscriptions WHERE active=1 AND end_at>datetime('now')")) .scalar() or 0
    s.close()
    return {"total_revenue": total, "today_revenue": today, "month_revenue": month, "active_subscriptions": active}

@app.get("/api/revenue/series")
def revenue_series():
    s = db()
    # aggregate per month (actual)
    rows = s.execute(text("""
        SELECT strftime('%Y-%m', created_at) as period, COALESCE(SUM(amount_cents),0) as total
        FROM payments WHERE status='succeeded'
        GROUP BY 1 ORDER BY 1
    """)).mappings().all()
    actual = [{"period": r["period"], "total": r["total"]} for r in rows]
    forecast = forecast_series(actual, months=6, growth=settings.DEFAULT_GROWTH_RATE) if actual else []
    s.close()
    return {"actual": actual, "forecast": forecast}

# =============== SANDBOX WEBHOOKS =====================
@app.post("/webhooks/stripe")
async def stripe_webhook(request: Request):
    body = await request.body()
    event = json.loads(body.decode('utf-8')) if body else {}
    # In sandbox, skip signature verification; in prod, verify headers['Stripe-Signature']
    s = db()
    entry_id = event.get('id', f"evt_{datetime.utcnow().timestamp()}")
    data = event.get('data', {})
    user_phone = data.get('phone', '+256700000001')
    plan = data.get('plan', 'monthly')
    amount_cents = int(data.get('amount_cents', 1500))
    currency = data.get('currency', 'USD')

    # map user
    row = s.execute(text("SELECT id FROM users WHERE phone=:p"), {"p": user_phone}).fetchone()
    if not row:
        s.execute(text("INSERT INTO users(phone,name,country,language) VALUES(:p,'User','UG','en')"), {"p": user_phone})
        user_id = s.execute(text("SELECT id FROM users WHERE phone=:p"), {"p": user_phone}).scalar()
    else:
        user_id = row[0]

    # idempotent payment insert
    s.execute(text("INSERT OR IGNORE INTO payments(provider,provider_txn_id,user_id,amount_cents,currency,plan,status,raw) VALUES('stripe',:id,:u,:a,:c,:pl,'succeeded',:raw)"),
              {"id": entry_id, "u": user_id, "a": amount_cents, "c": currency, "pl": plan, "raw": json.dumps(event)})

    # activate subscription (30 days monthly, 7 weekly, 1 daily, 365 elite/annual)
    now = datetime.utcnow()
    days = 30 if plan=="monthly" else 7 if plan=="weekly" else 1 if plan=="daily" else 365
    end = now + timedelta(days=days)
    s.execute(text("INSERT INTO subscriptions(user_id,plan,price_cents,currency,start_at,end_at,active) VALUES(:u,:p,:pc,:c,:st,:en,1)"),
              {"u": user_id, "p": plan, "pc": amount_cents, "c": currency, "st": now, "en": end})

    s.commit(); s.close()
    return {"ok": True}

@app.post("/webhooks/paypal")
async def paypal_webhook(request: Request):
    # identical to stripe for staging; in prod, verify signature
    return await stripe_webhook(request)

@app.post("/webhooks/flutterwave")
async def flutterwave_webhook(request: Request):
    # identical to stripe for staging; in prod, verify hash header
    return await stripe_webhook(request)

# =============== WHATSAPP SANDBOX ENDPOINTS ===========
@app.get("/whatsapp/verify")
async def whatsapp_verify(hub_mode: str, hub_challenge: str, hub_verify_token: str):
    if hub_verify_token != settings.WHATSAPP_VERIFY_TOKEN:
        raise HTTPException(status_code=403, detail="Bad verify token")
    return HTMLResponse(content=hub_challenge)

@app.post("/whatsapp/webhook")
async def whatsapp_webhook(request: Request):
    payload = await request.json()
    # very simple sandbox responder
    msg = (payload.get('messages') or [{}])[0]
    text = (msg.get('text') or {}).get('body', '').lower()
    phone = (msg.get('from') or '+256700000001')
    s = db()
    if 'subscribe' in text:
        # Simulate a payment success via staging webhook
        fake_event = {"id": f"evt_{datetime.utcnow().timestamp()}", "data": {"phone": phone, "plan": "monthly", "amount_cents": 1500, "currency": "USD"}}
        # Call local function directly
        from fastapi.testclient import TestClient
        client = TestClient(app)
        client.post('/webhooks/stripe', json=fake_event)
        reply = "‚úÖ Subscribed to Monthly. You'll receive job alerts now."
    elif 'wallet' in text:
        uid = s.execute(text("SELECT id FROM users WHERE phone=:p"), {"p": phone}).scalar()
        bal = s.execute(text("SELECT balance_cents FROM wallets WHERE user_id=:u"), {"u": uid}).scalar() or 0
        reply = f"üíº Wallet balance: ${bal/100:.2f}"
    elif 'jobs' in text:
        jobs = s.execute(text("SELECT title,country,requirements,salary_usd FROM jobs ORDER BY created_at DESC LIMIT 3")).fetchall()
        if jobs:
            lines = [f"üîé Top jobs:" ] + [f"‚Ä¢ {j[0]} ({j[1]}) ‚Äî ${j[3]}/mo\n  Requirements: {j[2]}" for j in jobs]
            reply = "\n".join(lines)
        else:
            reply = "No jobs yet, try again later."
    else:
        reply = "üëã Hi! Send 'subscribe' to activate, 'jobs' to view, 'wallet' to check balance."
    s.close()
    return {"reply": reply}

# =============== UTIL: add referral credit (sandbox) ===
@app.post("/sandbox/referral/credit")
async def referral_credit(phone: str, count: int = 1):
    s = db()
    uid = s.execute(text("SELECT id FROM users WHERE phone=:p"), {"p": phone}).scalar()
    if not uid:
        return JSONResponse({"ok": False, "error": "user not found"}, status_code=404)
    # $0.50 per referral base (staging)
    delta = 50 * count
    wallet_adjust(s, uid, delta_cents=delta, currency='USD', reason='referral_bonus')
    s.commit(); s.close()
    return {"ok": True, "credited_cents": delta}
```

---

## üß± backend/Dockerfile
```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

---

## üìò README.md (quick start)
```md
# WhatsApp Job App ‚Äî Staging Starter

## Run
1) Copy `.env.example` to `.env` and adjust if needed (sandbox keys optional for local test).
2) `docker compose up --build`
3) Open http://localhost:8000 ‚Üí Dashboard (cards + **line graph + forecast**)

## Test payments (sandbox)
- Simulate a Stripe payment:
  ```bash
  curl -X POST http://localhost:8000/webhooks/stripe \
       -H 'Content-Type: application/json' \
       -d '{"id":"evt_test_1","data":{"phone":"+256700000001","plan":"monthly","amount_cents":1500,"currency":"USD"}}'
  ```
- Refresh dashboard ‚Üí revenue updates instantly.

## Test WhatsApp sandbox
- Simulate WhatsApp inbound:
  ```bash
  curl -X POST http://localhost:8000/whatsapp/webhook \
       -H 'Content-Type: application/json' \
       -d '{"messages":[{"from":"+256700000001","text":{"body":"subscribe"}}]}'
  ```
- Response includes the auto-subscription message.

## Test referrals ‚Üí wallet credit
```bash
curl -X POST "http://localhost:8000/sandbox/referral/credit?phone=+256700000001&count=5"
```

## What‚Äôs included
- ‚úÖ Auto payments ‚Üí subscription activation
- ‚úÖ Revenue summary, **line graph (actual)** + **dashed forecast**
- ‚úÖ Referral credit ‚Üí wallet balance
- ‚úÖ WhatsApp-like commands: `subscribe`, `jobs`, `wallet`

## Next steps for production
- Replace SQLite with Postgres
- Enable real signature verification for Stripe/PayPal/Flutterwave webhooks
- Connect real WhatsApp Cloud API (set verify token + webhook URL)
- Add AI problem solver hooked to your DB and ticketing
- Add real payouts via provider APIs (mobile money/bank/PayPal/crypto)
- Harden security (MFA admin, WAF/rate limits, SIEM alerts)
